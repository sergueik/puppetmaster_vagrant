USE test;
-- setup
-- some realistic data , generating events, doing some querying afterwards

DROP TABLE IF EXISTS events;
CREATE TABLE IF NOT EXISTS events (
  APP VARCHAR(10) NOT NULL,
  STATUS TINYINT DEFAULT 0,
  EVENT_DATE DATETIME NOT NULL
);


DROP INDEX events_idx ON events;
CREATE INDEX events_idx ON events(APP, EVENT_DATE);

DROP PROCEDURE `fill_table` ;
DELIMITER //
CREATE PROCEDURE `fill_table`()
BEGIN
DECLARE V_EVENT_DATE0 DATETIME DEFAULT CURDATE();
DECLARE V_EVENT_DATE DATETIME DEFAULT DATE_SUB(CURDATE(), INTERVAL 10 DAY);
DECLARE V_VERBOSE TINYINT DEFAULT 0;
DECLARE V_APP VARCHAR(10);
DECLARE V_COUNT INTEGER DEFAULT 0;
DECLARE V_STATUS TINYINT DEFAULT 0;

INS: LOOP
  IF V_COUNT > 10 THEN
    LEAVE INS;
  END IF ;
  SET V_COUNT =  V_COUNT + 1 ;
  SET V_EVENT_DATE = DATE_ADD(V_EVENT_DATE0, INTERVAL V_COUNT SECOND);
  SET V_STATUS = MOD(V_COUNT, 5);
  SET V_APP = 'A1';
  INSERT INTO events (EVENT_DATE, APP, STATUS)
  VALUES (V_EVENT_DATE, V_APP, V_STATUS );
  SELECT V_APP, V_EVENT_DATE, V_STATUS , V_COUNT;
END LOOP;
END
//
DELIMITER ;

CALL `fill_table`();

DROP PROCEDURE `find_subsequent_errors` ;

DELIMITER //
CREATE PROCEDURE `find_subsequent_errors`()

BEGIN

DECLARE V_EVENT_DATE DATETIME DEFAULT CURDATE();
DECLARE V_COUNT INTEGER DEFAULT 0;
DECLARE V_APP VARCHAR(10);
DECLARE V_FOLLOWING_STATUS TINYINT DEFAULT 0;

DECLARE data_cursor CURSOR FOR SELECT APP, EVENT_DATE FROM events
  WHERE STATUS <> 0 ORDER BY APP, EVENT_DATE;

-- (un)commenting the next block expooses the stored pcedure to throwing / suppresses the 
-- ERROR 1329 (02000):
-- No data - zero rows fetched, selected, or processed

DECLARE CONTINUE HANDLER FOR NOT FOUND
BEGIN
  SELECT 1 INTO @handler_invoked FROM (SELECT 1) AS t;
END;
-- based on: https://stackoverflow.com/questions/3463283/how-to-get-rid-of-error-1329-no-data-zero-rows-fetched-selected-or-process
OPEN data_cursor;
INS: LOOP
  FETCH NEXT FROM data_cursor INTO V_APP,V_EVENT_DATE;
  IF V_COUNT > 10 THEN
    LEAVE INS;
  END IF;
  SET V_COUNT =  V_COUNT + 1;
END LOOP;
END
//
DELIMITER ;

CALL `find_subsequent_errors`();
